# -*- coding: utf-8 -*-
"""Linear Regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SpAplBM2A-Ybqg0T6F--NmuhlEB9q-82
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

np.random.seed(seed=1)
X_min = 4
X_max = 30
X_n = 16
X = 5 + 25 * np.random.rand(X_n)
X = np.round(X, 2)
Prm_c = [170, 108, 0.2]
T = Prm_c[0] - Prm_c[1] * np.exp(-Prm_c[2] * X) + 4 * np.random.randn(X_n)
T = np.round(T, 2)

np.savez('ch5_data.npz', X=X, X_min=X_min, X_max=X_max, X_n=X_n, T=T)

def mse_cost(x, t, w):
  y = w[0] * x + w[1]
  mse = np.mean((y-t)**2)
  return mse

def mse_slope(x, t, w):
  y = w[0] * x + w[1]
  d_w0 = 2* np.mean((y-t)*x)
  d_w1 = 2* np.mean(y-t)
  return d_w0, d_w1

def mse_optimum_weight_finder(x, t):
  w_init = [10.0, 165.0]
  alpha = 0.001
  n_max = 10000
  eps = 0.1
  w_n = np.zeros([n_max, 2])
  w_n[0,:] = w_init
  for n in range(1, n_max):
    slope = mse_slope(x, t, w_n[n-1])
    w_n[n, 0] = w_n[n-1, 0] - alpha * slope[0]
    w_n[n, 1] = w_n[n-1, 1] - alpha * slope[1]
    loss = mse_cost(x, t, w_n[n-1])
    if max(np.absolute(slope)) < eps:
      break
  w0 = w_n[n, 0]
  w1 = w_n[n, 1]
  return w0, w1, loss

k = mse_optimum_weight_finder(X, T)
print(k)

xn = 100
w0_range = [-25, 25]
w1_range = [120, 170]
x0 = np.linspace(w0_range[0], w0_range[1], xn)
x1 = np.linspace(w1_range[0], w1_range[1], xn)
xx0, xx1 = np.meshgrid(x0, x1)
J = np.zeros((len(x0),len(x1)))

for i0 in range(xn):
  for i1 in range(xn):
    J[i1, i0] = mse_line(X, T, (x0[i0], x1[i1]))

print(J)

def cost_mse(x, t, w0, w1):
  y = w0 * x + w1
  cost = np.mean((y-t)**2)
  return np.round(cost, 2)

def next_w(x, t, w0, w1, a):
  y = w0 * x + w1
  grad_w0 = 2 * np.mean((y-t)*x)
  grad_w1 = 2 * np.mean(y-t)
  next_w0 = w0 - a*grad_w0
  next_w1 = w0 - a*grad_w1
  return next_w0, next_w1

def linear_optimizer(x, t, i_max, w0, w1):
  for i in range(1, i_max):
    loss = cost_mse(x, t, w0, w1)
    eps = 100
    w0, w1 = next_w
    print(loss)
    if max(np.abs(loss)) < eps:
      break
  return loss