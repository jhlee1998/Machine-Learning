# -*- coding: utf-8 -*-
"""Cross Entropy 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MJESEmOULx5dS0OAsHOjLQ6R41Cis9gC
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

np.random.seed(seed=0)
X_min=0
X_max=2.5
X_n=30
X_col=['red','blue']
X=np.zeros(X_n)
T=np.zeros(X_n, dtype=np.uint8)
Dist_s=[0.4,0.8]
Dist_w=[0.8,1.6]
Pi = 0.5
for n in range(X_n):
  wk=np.random.rand()
  T[n]=0*(wk < Pi) + 1 * (wk >= Pi)
  X[n]=np.random.rand() * Dist_w[T[n]]+Dist_s[T[n]]

print('X=' +str(np.round(X,2)))
print('T=' +str(T))

def show_data1(x,t):
  K=np.max(t)+1
  for k in range(K):
     plt.plot(x[k==t], t[k==t], X_col[k], alpha=0.5, linestyle='none', marker='o')
     plt.grid(True)
     plt.ylim(-.5, 1.5)
     plt.xlim(X_min, X_max)
     plt.yticks([0,1])
fig = plt.figure(figsize=(3,3))
show_data1(X,T)
plt.show()

def sigmoid(x,w):
  y=1/(1+np.exp(-(w[0]*x+w[1])))
  return y

def show_sigmoid(w):
  xb = np.linspace(X_min, X_max, 100)
  y = sigmoid(xb, w)
  plt.plot(xb, y, color='gray', linewidth=4)
  i = np.min(np.where(y>0.5))
  B = (xb[i-1]+xb[i]) / 2
  plt.plot([B, B], [-.5, 1.5], color='k', linestyle='--')
  plt.grid(True)
  return B

W = [10, -10]
show_sigmoid(W)

def cce_cost(w, x, t):
  y = sigmoid(x, w)
  cost = 0
  for n in range(len(y)):
    cost = cost - (t[n]*np.log(y[n])+(1-t[n])*np.log(1-y[n]))
  cost = cost / X_n
  return cost

W=[2,1]
cce_cost(W, X, T)

def cce_slope(w,x,t):
  y=sigmoid(x,w)
  slope=np.zeros(2)
  for n in range (len(y)):
    slope[0]=slope[0]+(y[n]-t[n])*x[n]
    slope[1]=slope[1]+(y[n]-t[n])
  slope=slope / X_n
  return slope

W=[1,1]
cce_slope(W, X, T)

def cce_optimum_weight_finder(x, t):
  w_init = [10, 10]
  alpha = 0.1
  n_max = 10000
  eps = 0.1
  w_n = np.zeros([n_max, 2])
  w_n[0,:] = w_init
  for n in range(1, n_max):
    slope = cce_slope(w_n[n-1], x, t)
    w_n[n, 0] = w_n[n-1, 0] - alpha * slope[0]
    w_n[n, 1] = w_n[n-1, 1] - alpha * slope[1]
    loss = cce_cost(w_n[n-1], x, t)
    print(loss)
    if max(np.absolute(slope)) < eps:
      break
  w0 = w_n[n, 0]
  w1 = w_n[n, 1]
  return w0, w1, loss

k = cce_optimum_weight_finder(X, T)
print(k)